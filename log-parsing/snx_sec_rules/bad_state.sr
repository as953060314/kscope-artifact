#/
# What is reported
# ~~~~~~~~~~~~~~~~
# Reports bad slot state in Sonexion. For instance, when a drive
# fails, its state becomes *Failed*. Send up to one email per minute,
# so errors can accumulate. The summary rule will then report
# recurring errors.  If the situation changes (ie. number of drives,
# or type of error, then a new email will be sent.
#
# Origin
# ~~~~~~
# **lmmon-aggregated.log**, which was generated from
# **lmmon-dm_report.log**, itself generated by
# *dm_report*.
#
# Instances of logged strings
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ::
#
#   Fri Jan 18 14:54:01 2013: snx11003n002: found 1 slot(s) in state 'Failed'
#   Tue Mar  5 12:41:54 2013: snx11003n109: found 1 slot(s) in state 'Empty'
#   Mon Mar 18 08:31:12 2013: snx11003n031: found 14 slot(s) in state 'Empty'
#/

type= single
continue=takenext
context = [AGGREGATED_LOG && !BAD_SLOT_STATE]
ptype= RegExp
pattern= (\d\d:\d\d:\d\d) \d+: snx(\d+)(n\d+): found (\d+) slot\(s\) in state '(.*)'
desc= bad slot state
action= create BAD_SLOT_STATE 60 (lcall %o -> ( sub { return $BAD_SLOT_STATE_count; } ) ; if %o (report _THIS %cmd "%{subject}: %o drive slot(s) in unexpected state (NEW)" %list)) ;\
        lcall %o -> ( sub { $BAD_SLOT_STATE_count = 0; } ) ;\
        add BAD_SLOT_STATE System:      %site %host, %mf ;\
        add BAD_SLOT_STATE Filesystem:  all ;\
        add BAD_SLOT_STATE Event:       Bad slot state. ;\
        add BAD_SLOT_STATE Time:      $1  %Tmsg ;\
        add BAD_SLOT_STATE %t  --  %tmsg2 ;\
        add BAD_SLOT_STATE %{rule_info}bad_state.sr ;\
        if %urlsr ( add BAD_SLOT_STATE %{urlsr}/bad_state.sr.html ) ;\
        add BAD_SLOT_STATE %{N} ;\
        add BAD_SLOT_STATE From log file: $+{_inputsrc}%{N} ;\
        add BAD_SLOT_STATE %{N}

# Create an event the first time we see it. If the event is not seen
# again for an hour, forget about it.
type= SingleWith2Thresholds
context = [AGGREGATED_LOG && BAD_SLOT_STATE]
ptype= RegExp
pattern= (\d\d:\d\d:\d\d) \d+: snx(\d+)(n\d+): found (\d+) slot\(s\) in state '(.*)'
desc= bad slot state %{fs}$2$3 $4 $5
action= lcall %o $2 $3 $5 $0 -> ( sub { $bad_slot_state{$_[0] . $_[1] . $_[2] } = $_[3]; } ) ;\
        add BAD_SLOT_STATE $0 ;\
        lcall %o -> ( sub { ++$BAD_SLOT_STATE_count; } )
window= 1
thresh= 1
desc2= bad slot state fixed %{fs}$2$3 $4 $5
action2= lcall %o $2 $3 $5 $0 -> ( sub { delete($bad_slot_state{$_[0] . $_[1] . $_[2] }); } );
window2=3600
thresh2=0
